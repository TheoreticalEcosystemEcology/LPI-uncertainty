---
title: "Accuracy and precision of the LPI"
output:
  bookdown::html_document2:
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: no
      smooth_scroll: no
    number_sections: no
    theme: flatly
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
# libraries
require(kableExtra)
require(ggplot2)
require(patchwork)
require(dplyr)
require(tidyr)
require(tidyselect)
library(readr)

# chunk params
knitr::opts_chunk$set(echo = FALSE, 
                      warning=FALSE, 
                      message=FALSE,
                      fig.height = 7, 
                      fig.align = "center")

# set ggplot theme
theme_set(theme_linedraw())
format_lpiplots <- list(
  theme(legend.position = "none"),
  labs(x = "", y = "LPI"),
  scale_x_continuous(breaks = seq(from = 0, to = 11, by = 2)),
  ylim(c(0, 2)))

# load results
df <- readRDS("~/Documents/GitHub/LPI-sensitivity/outputs/all_results.RDS")

# colour palette for interactions
colours <- c("Strong Asynchrony" = "#e66101", 
             "Weak Asynchrony" = "#fdb863", 
             "Weak Synchrony"= "#b2abd2", 
             "Strong Synchrony" = "#5e3c99")

# colour palette for process error plots
pal_lags <- rev(c("#22A884FF", "#2A788EFF", "#414487FF"))
pal_error <- c("#08306b", "#2171b5", "#6baed6")
pal_compare <- c("raw" = "blue", "predicted" = "red")
```


```{r}
df$Process_error <- factor(df$Process_error, levels = c("0", "0.1", "0.2"))
df$interaction <- gsub("-0.2", "Strong Synchrony", df$interaction) 
df$interaction <- gsub("-0.1", "Weak Synchrony", df$interaction) 
df$interaction <- gsub("0.1", "Weak Asynchrony", df$interaction) 
df$interaction <- gsub("0.2", "Strong Asynchrony", df$interaction) 
df$interaction <- gsub("0", "No Synchrony", df$interaction) 

df$interaction <- factor(df$interaction, 
                         levels = c("Strong Asynchrony", "Weak Asynchrony", "No Synchrony", "Weak Synchrony", "Strong Synchrony"))
```

```{r}
accuracy_plot <- function(df_subset, comparison_variable, colour_variable = "direction") {
  ggplot(df_subset,
       aes(x = get(comparison_variable),
           y = accuracy, 
           group = scenario,
           col = get(colour_variable))) +
  geom_hline(yintercept = 0, lwd = 0.5) +
  geom_violin(aes(fill = get(colour_variable),
                  y = accuracy),
              alpha = .3, lwd = 0,
              position = position_dodge(width = .5)) +
  stat_summary(fun.data = mean_se, 
               fun.args = list(mult=1),
               geom = "pointrange", 
               position = position_dodge(width = .5)) + 
  labs(x = "", 
       y = expression(Delta~from~true~LPI), 
       title = "Trend bias", 
       col = colour_variable, 
       fill = colour_variable) +
  theme(legend.position = "bottom") 
}

precision_plot <- function(df_subset, comparison_variable, colour_variable = "direction"){
  
  ggplot(data = df_subset, aes(x = get(comparison_variable), 
                        group = scenario,
                        col = get(colour_variable))) +
  geom_violin(aes(fill = get(colour_variable),
                  y = CI_diff),
              alpha = .3, lwd = 0,
              position = position_dodge(width = .5)) +
  stat_summary(aes(y = CI_diff),
               fun.data = mean_se,
               fun.args = list(mult=1),
               geom = "pointrange",
               position = position_dodge(width = .5)) +
    labs(y = expression(Delta~from~true~uncertainty~interval), 
         x = "", 
         title = "Uncertainty bias",
         col = colour_variable,
         fill = colour_variable) +
 theme(legend.position = "bottom") 
}


reasonable_precision_plot <- function(df_subset, comparison_variable, colour_variable = "direction") {
    ggplot(data = df_subset, aes(x = get(comparison_variable), 
                        group = scenario,
                        col = get(colour_variable))) +
  geom_violin(aes(fill = get(colour_variable),
                  y = rlpiCI_relativewidth),
              alpha = .3, lwd = 0,
              position = position_dodge(width = .5)) +
  stat_summary(aes(y = rlpiCI_relativewidth),
               fun.data = mean_se,
               fun.args = list(mult=1),
               geom = "pointrange",
               position = position_dodge(width = .5)) +
    geom_hline(aes(yintercept = 0.1), lty = 2) +
    labs(y = "Relative width of the CI", 
         x = "", 
         title = "Reasonable level of precision",
         col = colour_variable,
         fill = colour_variable) +
 theme(legend.position = "bottom") 
}

overlap_precision_plot <- function(df_subset, comparison_variable, colour_variable = "direction") {
  ggplot(data = df_subset, aes(x = get(comparison_variable), 
                               group = scenario,
                               col = get(colour_variable))) +
    geom_violin(aes(fill = get(colour_variable),
                    y = overlap),
                alpha = .3, lwd = 0,
                position = position_dodge(width = .5)) +
    stat_summary(aes(y = overlap),
                 fun.data = mean_se,
                 fun.args = list(mult=1),
                 geom = "pointrange",
                 position = position_dodge(width = .5)) +
    labs(y = "Overlap %", 
         x = "", 
         title = "Overlap between raw and smoothed growth rate distributions",
         col = colour_variable,
         fill = colour_variable) +
    theme(legend.position = "bottom") +
    coord_cartesian(ylim = c(0,1))
}

percentile_precision_plot <- function(df_subset, comparison_variable, colour_variable = "direction") {
    ggplot(data = df_subset, aes(x = get(comparison_variable), 
                        group = scenario,
                        col = get(colour_variable))) +
  geom_violin(aes(fill = get(colour_variable),
                  y = percentile),
              alpha = .3, lwd = 0,
              position = position_dodge(width = .5)) +
    geom_hline(aes(yintercept = 0.5), lty = 2) +
  stat_summary(aes(y = percentile),
               fun.data = mean_se,
               fun.args = list(mult=1),
               geom = "pointrange",
               position = position_dodge(width = .5)) +
    labs(y = "Percentile", 
         x = "", 
         title = "True mean percentile in the bootstrapped distribution?",
         col = colour_variable,
         fill = colour_variable) +
 theme(legend.position = "bottom") +
    coord_cartesian(ylim = c(0,1))
}
```

***

## Mechanistic simulations of population dynamics

We simulated antagonistic population dynamics using a discrete Lotka-Volterra competition model, where each population's growth rate is influenced by the fluctuations in a competitor population.
Pairs of populations were simulated according to:

```{=tex}
\begin{equation}
N_i(t+1) = N_i(t) + \lambda_i * N_i(t)
\end{equation}
```

where $N_i$ is the size of population $i$, $t$ is each time step, and $\lambda$ is the true growth rate of population $i$.
The true growth rate ($\lambda$) is determined by:

```{=tex}
\begin{equation}
\lambda_i = r*(1-\frac{(N_i(t) + \alpha_{ji}N_j(t))}{K_i})
\end{equation}
```

where $r$ is population $i$'s maximum growth rate, $\alpha_{ji}$ is the interaction effect of population $j$ on population $i$, $N_j$ is the size of population $j$, and $K_i$ is the carrying capacity of population $i$.

To test index sensitivity to error, we introduced process and observation error into the generated population time series.

```{r}
params <- data.frame("Value" = c(10, 10, 100, 1.5), 
                     row.names = c("Number of population pairs", 
                                   "Time steps",
                                   "Initial size (N0)",
                                   "Maximum growth rate (r)"))
kbl(params, booktabs = TRUE, caption = "Constant simulation parameters") %>%
  kable_styling(position = "center", latex_options = "hold_position")
```

***

### Biodiversity change scenarios

#### Direction of change

To test index sensitivity to direction of change, we generated three scenarios of population-level biodiversity change.

We varied carrying capacity through time to drive populations to:

* (1) decline in response to decreasing carrying capacity, representing situations where habitats are lost or altered,   
* (2) remain stable in response to constant carrying capacity, where habitats are left untouched, or 
* (3) increase in response to increasing carrying capacity, where habitat quality and/or availability increases through time.

In each scenario, carrying capacity begins at $K = 100$ and each population's initial size is exactly at this carrying capacity ($N_0 = 100$). 

```{r, fig.cap = "Carrying capacity trends used to generate the biodiversity change scenarios.", fig.align="center"}
knitr::include_graphics(here::here('figures/carryingcapacity.png'))
```


#### Covariance

To test whether the LPI is sensitive to lags in the covariance between populations, we then generated two levels of lag in the interaction effect dictating how populations covary through time:

* The first level was lag-1, where the interaction effect of populations $i$ on populations $j$ was dependent on the abundance of populations $i$ at the previous time step ($t-1$).
* The second level was lag-2, where this interaction effect depended instead on the abundance of populations $i$ from two time steps ago ($t-2$).

***

## Measuring index sensitivity

For each biodiversity change scenario, index sensitivity was measured as the accuracy and precision of the calculated Living Planet Index when compared to the true biodiversity change trend. This true LPI trend was obtained by calculating the index values through time based on a population generated from the same parameters we used to generate populations for each scenario, without any added process error.


We measured **accuracy** as the difference between the calculated LPI and true LPI trend at each time step:

$$accuracy = LPI_{calculated} - LPI_{true}$$ 

As a first metric of **precision**, we evaluated whether the true LPI trend fell within the 95% confidence interval around the calculated LPI trend obtained from bootstrap resampling at each time step. As a second precision metric, we measured precision as the difference between the expected uncertainty interval and the width of the 95% confidence interval. The expected uncertainty interval is determined based on the process and observation errors introduced into the simulated population trends. I calculated each population's growth rate with and without introduced error, and took the difference between the two to get a measure of the total introduced uncertainty in the growth rates. Then, I converted this uncertainty to the same scale as the LPI:

$$ precision = LPI_{CIwidth} - LPI_{uncertainty} $$

***

## Is the LPI sensitive to *direction of change*? {.tabset .tabset-pills}

```{r}
## make table ##
params <- data.frame("i" = c(0, 
                             paste0("+/- ", 5), 
                             paste0("+/- ", " 0, 0.1, 0.2"), 0), 
                     "j" = c(0, 
                             paste0("+/- ", 5), 
                             paste0("+/- ", "0, 0.1, 0.2"), 0),
                     row.names = c("Interaction effect (alpha)",
                                   "Observation error",
                                   "Process error", 
                                   "Lag"))
kbl(params, booktabs = TRUE, caption = "Simulation parameters") %>%
  kable_styling(position = "center", latex_options = "hold_position")
```

### Process error = 0

```{r, fig.cap="True and calculated LPI trends for each direction of biodiversity change."}
# this was scenario 1, so filter for just that one
df_sc1 <- dplyr::filter(df, scenario %in% paste0("scenario1", LETTERS[1:9]))
(d <- ggplot(dplyr::filter(df_sc1, Process_error == "0"),
       aes(x = time, col = direction, group = scenario)) +
  geom_ribbon(aes(ymin = CI_low, ymax = CI_high, 
                   fill = direction), alpha = .3, lwd = 0) +
  geom_line(aes(y = LPI_final_true), lty = 2, lwd = .2) +
  geom_line(aes(y = LPI_final)) +
  theme_bw() + format_lpiplots)
```

### Process error = 0.1

```{r, fig.cap="True and calculated LPI trends for each direction of biodiversity change."}
ggplot(dplyr::filter(df_sc1, Process_error == "0.1"),
       aes(x = time, col = direction, group = scenario)) +
  geom_ribbon(aes(ymin = CI_low, ymax = CI_high, 
                   fill = direction), alpha = .3, lwd = 0) +
  geom_line(aes(y = LPI_final_true), lty = 2, lwd = .2) +
  geom_line(aes(y = LPI_final)) +
  theme_bw() + format_lpiplots
```


### Process error = 0.2

```{r, fig.cap="True and calculated LPI trends for each direction of biodiversity change."}
ggplot(dplyr::filter(df_sc1, Process_error == "0.2"),
       aes(x = time, col = direction, group = scenario)) +
  geom_ribbon(aes(ymin = CI_low, ymax = CI_high, 
                   fill = direction), alpha = .3, lwd = 0) +
  geom_line(aes(y = LPI_final_true), lty = 2, lwd = .2) +
  geom_line(aes(y = LPI_final)) +
  theme_bw() + format_lpiplots
```

## Summary {.tabset .tabset-pills}

### Process error = 0

```{r, fig.cap = "LPI sensitivity to direction of change."}
a <- accuracy_plot(filter(df_sc1, Process_error == "0"), "direction") + 
  theme(legend.position = "none") 
b <- precision_plot(filter(df_sc1, Process_error == "0"), "direction") + 
  theme(legend.position = "none") 
a + b
```


```{r, include = FALSE, echo = FALSE}
(d + labs(title = "Trends")) / (a + b)
ggsave("~/Documents/GitHub/LPI-sensitivity/figures/fig2_direction.png", width = 6.7, height = 7.74)
```


### Process error = 0.1

```{r, fig.cap = "LPI sensitivity to direction of change."}
a <- accuracy_plot(filter(df_sc1, Process_error == "0.1"), "direction") + 
  theme(legend.position = "none")
b <- precision_plot(filter(df_sc1, Process_error == "0.1"), "direction") + 
  theme(legend.position = "none") 
a + b
```



### Process error = 0.2

```{r, fig.cap = "LPI sensitivity to direction of change."}
a <- accuracy_plot(filter(df_sc1, Process_error == "0.2"), "direction") + 
  theme(legend.position = "none")
b <- precision_plot(filter(df_sc1, Process_error == "0.2"), "direction") + 
  theme(legend.position = "none") 
a + b
```



### Summary table

```{r, out.width = 9, include=TRUE}
# calculate mean accuracy and mean precision with standard error
se <- function(x) sqrt(var(x)/length(x))
df_sc1 %>% 
  group_by(direction, Process_error) %>%
  summarise(mean_accuracy = round(mean(accuracy),2),
            mean_precision = round(mean(CI_diff),3)) %>%
  kableExtra::kable() %>% kableExtra::kable_styling()
```
## {-}

```{r, out.width = 9, include=TRUE}
temp <- paste0("scenario1", LETTERS[1:9])
sc1 <- lapply(temp, function(x) {readRDS(here::here(paste0("outputs/",x,"_results.RDS")))})
names(sc1) <- temp
sc1 <- bind_rows(sc1, .id = "scenario")

means <- group_by(sc1, scenario) %>%
  summarise(mu_raw = mean(N),
            mu_pred = mean(N_pred)
            )

ggplot(sc1)+
  geom_density(aes(x = N, fill = "raw", col = "raw"), 
               alpha = .3, lwd = .1) +
  geom_density(aes(x = N_pred, fill = "predicted", col = "predicted"), 
               alpha = .3, lwd = .1) +
  geom_vline(data = means, aes(xintercept = mu_raw, 
                               col = "raw"), lwd = .5) +
  geom_vline(data = means, aes(xintercept = mu_pred, 
                               col = "predicted"), lwd = .5) +
  scale_fill_manual(values = pal_compare) + 
  scale_color_manual(values = pal_compare) +
  facet_wrap(~scenario, scales = "free") +
  labs(col = "Source", fill = "Source")
```

## {-}

```{r, fig.cap="Ability to capture the true LPI", fig.width=7, fig.height = 5}
success = df_sc1 %>% group_by(direction, Process_error) %>%
  count(true_within_rlpiCI) %>%
  mutate(perc = n/sum(n)) %>% 
  ungroup() %>%
  filter(true_within_rlpiCI == "Success")
  
success %>% 
  ggplot() +
  geom_tile(aes(x = direction, y = Process_error, fill = perc)) +
  scale_fill_distiller(palette = "RdYlGn", direction = 1, limits = c(0,1)) +
  labs(fill = "Success rate", y = "", x = "")

success %>% kable() %>% kable_styling(bootstrap_options = "striped") %>%
  scroll_box(width = "100%", height = "200px")
```

```{r, fig.cap="Ability to capture the true LPI", fig.width=7, fig.height = 5}
overlap_precision_plot(filter(df_sc1, Process_error == "0"), comparison_variable = "direction")
percentile_precision_plot(filter(df_sc1, Process_error == "0"), comparison_variable = "direction")
```


```{r, fig.width=7, fig.height = 5}
reasonable_precision_plot(df_sc1, comparison_variable = "Process_error") +
  labs(x = "Process error")
```


```{r, echo = FALSE, include = FALSE}
# process error comparison plot
a <- df_sc1 %>%
  group_by(direction, Process_error) %>%
  summarise(mean_se(accuracy)) %>%
ggplot(aes(col = Process_error, y = y, x = direction)) +
  geom_errorbar(aes(ymin = ymin, ymax = ymax), lwd = .5, width = 0) +
  geom_point(size = 2.5) +
  geom_hline(yintercept = 0, lty = 2, lwd = .2) +
  labs(y = "Difference from true LPI", 
         title = "Accuracy",
       x = "",
         col = "Process error") +
 theme(legend.position = "bottom") +
  scale_color_manual(values = pal_error)
b <- df_sc1 %>%
  group_by(direction, Process_error) %>%
  summarise(mean_se(CI_diff)) %>%
ggplot(aes(col = Process_error, y = y, x = direction)) +
  geom_errorbar(aes(ymin = ymin, ymax = ymax), lwd = .5, width = 0) +
  geom_point(size = 2.5) +
  geom_hline(yintercept = 0, lty = 2, lwd = .2) +
  labs(y = "Difference in interval width", 
         title = "Precision",
         col = "Process error",
       x = "") +
 theme(legend.position = "bottom") +
  scale_color_manual(values = pal_error)
a + b
ggsave("~/Documents/GitHub/LPI-sensitivity/figures/figsupp_direction.png", width = 7.6, height = 3.7)
```
  

***

## Is the LPI sensitive to *covariance*? {.tabset .tabset-pills}

To test whether the LPI is sensitive to covariance between populations, we generated biodiversity change scenarios with two types of interaction effects ($\alpha$) between populations:

* For the first scenario, we set a **negative interaction effect** to represent an antagonistic interaction between populations $i$ and $j$, such as a competitive or predator-prey relationship, which causes negative covariance.  
* The second scenario was based on a **positive interaction effect** of the same magnitude(s) to replicate a positive interaction between populations $i$ and $j$, and therefore positive covariance.

Each type of interaction was tested at two interaction strengths. All interaction effects were immediate, meaning there was no time lag in the covariance in the populations' growth rates. 

```{r}
## make table ##
params <- data.frame("i" = c(0, 
                             paste0("+/- ", 5), 
                             paste0("+/- ", " 0, 0.1, 0.2"), 0), 
                     "j" = c(0, 
                             paste0("+/- ", 5), 
                             paste0("+/- ", "0, 0.1, 0.2"), 0),
                     row.names = c("Interaction effect (alpha)",
                                   "Observation error",
                                   "Process error",
                                   "Lag"))
kbl(params, booktabs = TRUE, caption = "Simulation parameters") %>%
  kable_styling(position = "center", latex_options = "hold_position") 

# combine into one df for later
df_sc2 <- df[grepl("^scenario2", df$scenario), ]
df_sc3 <- df[grepl("^scenario3", df$scenario), ]
df_cov <- rbind(df_sc1, df_sc2, df_sc3)
```

### Process error = 0

```{r, fig.cap="True and calculated LPI trends for each scenario.", fig.height = 7}
df_sc2 <- df[grepl("^scenario2", df$scenario), ] %>% dplyr::filter(Process_error == "0")
df_sc3 <- df[grepl("^scenario3", df$scenario), ] %>% dplyr::filter(Process_error == "0")
a <- ggplot(df_sc2,
       aes(x = time, group = scenario, col = direction)) +
    geom_ribbon(aes(ymin = CI_low, ymax = CI_high, 
                   fill = direction), alpha = .3, lwd = 0) +
  geom_line(aes(y = LPI_final)) +
  geom_line(aes(y = LPI_final_true), lty = 2) +
  facet_wrap(~interaction) +
  theme_bw() + format_lpiplots +
  labs(title = "Predation (negative covariation)")
b <- ggplot(df_sc3,
       aes(x = time, group = scenario, col = direction)) +
    geom_ribbon(aes(ymin = CI_low, ymax = CI_high, 
                   fill = direction), alpha = .3, lwd = 0) +
  geom_line(aes(y = LPI_final)) +
  geom_line(aes(y = LPI_final_true), lty = 2) +
  facet_wrap(~interaction) +
  theme_bw() + format_lpiplots +
  labs(title = "Competition (positive covariation)")
a / b
```


### Process error = 0.1

```{r, fig.cap="True and calculated LPI trends for each scenario.", fig.height = 7}
df_sc2 <- df[grepl("^scenario2", df$scenario), ] %>% dplyr::filter(Process_error == "0.1")
df_sc3 <- df[grepl("^scenario3", df$scenario), ] %>% dplyr::filter(Process_error == "0.1")
a <- ggplot(df_sc2,
       aes(x = time, group = scenario, col = direction)) +
    geom_ribbon(aes(ymin = CI_low, ymax = CI_high, 
                   fill = direction), alpha = .3, lwd = 0) +
  geom_line(aes(y = LPI_final)) +
  geom_line(aes(y = LPI_final_true), lty = 2) +
  facet_wrap(~interaction) +
  theme_bw() + format_lpiplots +
  labs(title = "Predation (negative covariation)")
b <- ggplot(df_sc3,
       aes(x = time, group = scenario, col = direction)) +
    geom_ribbon(aes(ymin = CI_low, ymax = CI_high, 
                   fill = direction), alpha = .3, lwd = 0) +
  geom_line(aes(y = LPI_final)) +
  geom_line(aes(y = LPI_final_true), lty = 2) +
  facet_wrap(~interaction) +
  theme_bw() + format_lpiplots +
  labs(title = "Competition (positive covariation)")
a / b
```

### Process error = 0.2

```{r, fig.cap="True and calculated LPI trends for each scenario.", fig.height = 7}
df_sc2 <- df[grepl("^scenario2", df$scenario), ] %>% dplyr::filter(Process_error == "0.2")
df_sc3 <- df[grepl("^scenario3", df$scenario), ] %>% dplyr::filter(Process_error == "0.2")
a <- ggplot(df_sc2,
       aes(x = time, group = scenario, col = direction)) +
    geom_ribbon(aes(ymin = CI_low, ymax = CI_high, 
                   fill = direction), alpha = .3, lwd = 0) +
  geom_line(aes(y = LPI_final)) +
  geom_line(aes(y = LPI_final_true), lty = 2) +
  facet_wrap(~interaction) +
  theme_bw() + format_lpiplots +
  labs(title = "Predation (negative covariation)")
b <- ggplot(df_sc3,
       aes(x = time, group = scenario, col = direction)) +
    geom_ribbon(aes(ymin = CI_low, ymax = CI_high, 
                   fill = direction), alpha = .3, lwd = 0) +
  geom_line(aes(y = LPI_final)) +
  geom_line(aes(y = LPI_final_true), lty = 2) +
  facet_wrap(~interaction) +
  theme_bw() + format_lpiplots +
  labs(title = "Competition (positive covariation)")
a / b
```


## Summary {.tabset .tabset-pills}

### Process error = 0

```{r, fig.cap = "LPI sensitivity to direction of change and covariance.", fig.height = 8}
df_temp <- dplyr::filter(df_cov, Process_error == "0") 
a <- accuracy_plot(df_temp, comparison_variable = "interaction") + theme(legend.position = "none")
b <- precision_plot(df_temp, comparison_variable = "interaction") 
a / b
ggsave("~/Documents/GitHub/LPI-sensitivity/figures/fig3_covariance.png", width = 6.14, height = 6.26)
```

### Process error = 0.1

```{r, fig.cap = "LPI sensitivity to direction of change and covariance.", fig.height = 8}
df_temp <- dplyr::filter(df_cov, Process_error == "0.1") 
a <- accuracy_plot(df_temp, comparison_variable = "interaction") + theme(legend.position = "none")
b <- precision_plot(df_temp, comparison_variable = "interaction")# +
  #coord_cartesian(ylim = c(-2,28))
a / b
```

### Process error = 0.2

```{r, fig.cap = "LPI sensitivity to direction of change and covariance.", fig.height = 8}
df_temp <- dplyr::filter(df_cov, Process_error == "0.2") 
a <- accuracy_plot(df_temp, comparison_variable = "interaction")
b <- precision_plot(df_temp, comparison_variable = "interaction")# +
  #coord_cartesian(ylim = c(-2,28))
a / b
```

## Summary table

```{r, include = TRUE}
df_cov %>% filter(Process_error == "0") %>%
  group_by(direction, interaction) %>%
  summarise(mean_accuracy = round(mean(accuracy),3),
            se_accuracy = round(se(accuracy), 3),
            mean_precision = round(mean(CI_diff),3),
            se_precision = round(se(CI_diff),3)) %>% 
  kableExtra::kable() %>%
  scroll_box(width = "100%", height = "200px")
```

```{r, fig.cap="Ability to capture the true LPI", fig.height=5, fig.width=9}
success = df_cov %>% group_by(direction, interaction, Process_error) %>%
  count(true_within_rlpiCI) %>%
  mutate(perc = n/sum(n)) %>% 
  ungroup() %>%
  filter(true_within_rlpiCI == "Success")
  
success %>% 
  ggplot() +
  geom_tile(aes(x = direction, y = interaction, fill = perc)) +
  facet_wrap(~Process_error, labeller = label_both) + 
  scale_fill_distiller(palette = "RdYlGn", direction = 1, limits = c(0,1)) +
  labs(fill = "Success rate", y = "", x = "")

success %>% kable() %>% kable_styling(bootstrap_options = "striped") %>%
  scroll_box(width = "100%", height = "200px")
```


```{r, fig.width=7, fig.height = 5}
reasonable_precision_plot(df_cov, comparison_variable = "interaction") +
facet_wrap(~Process_error, dir = "v")
```

```{r, fig.cap="Ability to capture the true LPI", fig.width=7, fig.height = 5}
overlap_precision_plot(filter(df_cov, Process_error == "0"), comparison_variable = "interaction")
percentile_precision_plot(filter(df_cov, Process_error == "0"), comparison_variable = "interaction")
```


```{r}
ggplot(df_cov) +
  geom_boxplot(aes(y = true_diff_rlpiCI, x = interaction, fill = direction)) +
  facet_wrap(~Process_error, dir = "v") +
  labs(y = "Truth's difference \nfrom confidence interval") +
  geom_hline(aes(yintercept = 0), lwd = .3)
```

    The LPI is sensitive to covariance when trends are declining:  
    
    * The LPI is particularly sensitive to negative covariance in declining trends, which are very overestimated (alpha = 0.1 and 0.2)  
    * growing and stable trends are slightly overestimated when there is high positive covariance  
    * however, this sensitivity does not change at different levels of process error   
    
```{r, echo = FALSE, include = FALSE}
# process error comparison plot
a <- df_cov %>%
  group_by(direction, interaction, Process_error) %>%
  summarise(mean_se(accuracy)) %>%
ggplot(aes(col = Process_error, y = y, x = direction)) +
  geom_errorbar(aes(ymin = ymin, ymax = ymax), lwd = .5, width = 0) +
  geom_point(size = 2.5) +
  geom_hline(yintercept = 0, lty = 2, lwd = .2) +
  facet_wrap(~interaction)+#, scales = "free") +
  labs(y = "Difference from true LPI", 
       title = "Accuracy", 
       x = "",
       col = "Process error") +
 theme(legend.position = "bottom") +
  scale_color_manual(values = pal_error)
b <- df_cov %>%
  group_by(direction, interaction, Process_error) %>%
  summarise(mean_se(CI_diff)) %>%
ggplot(aes(col = Process_error, y = y, x = direction)) +
  geom_errorbar(aes(ymin = ymin, ymax = ymax), lwd = .5, width = 0) +
  geom_point(size = 2.5) +
  geom_hline(yintercept = 0, lty = 2, lwd = .2) +
  facet_wrap(~interaction)+#, scales = "free") +
  labs(y = "Difference in interval width", 
         col = "Process error", 
         title = "Precision",
         x = "") +
 theme(legend.position = "bottom") +
  scale_color_manual(values = pal_error)
a + b
ggsave("~/Documents/GitHub/LPI-sensitivity/figures/figsupp_covariance.png", width = 10, height = 7)
```
    
    
## Is the LPI sensitive to *lagged* covariance? 

We introduced two levels of lag in the interaction effect that influences how populations covary through time:

* The first level was **lag-1**, where the interaction effect of populations $i$ on populations $j$ was dependent on the abundance of populations $i$ at the previous time step ($t-1$).
* The second level was **lag-2**, where this interaction effect depended instead on the abundance of populations $i$ from two time steps ago ($t-2$).

Both of these lags were introduced into positively and negatively covarying populations shown above.

```{r}
## make table ##
params <- data.frame("i" = c(0, 
                             paste0("+/- ", 5), 
                             paste0("+/- ", " 0, 0.1, 0.2"),
                             c("0, 1, 2")), 
                     "j" = c(0, 
                             paste0("+/- ", 5), 
                             paste0("+/- ", "0, 0.1, 0.2"),
                             c("0, 1, 2")),
                     row.names = c("Interaction effect (alpha)",
                                   "Observation error",
                                   "Process error",
                                   "Lag"))
kbl(params, booktabs = TRUE, caption = "Simulation parameters") %>%
  kable_styling(position = "center", latex_options = "hold_position")

# combine into one df for later
df_sc2 <- df[grepl("^scenario2", df$scenario), ]
df_sc3 <- df[grepl("^scenario3", df$scenario), ]
df_cov <- rbind(df_sc2, df_sc3)
```

### Positive covariance {.tabset .tabset-pills}

#### Process error = 0

```{r, fig.height=5}
ggplot(dplyr::filter(df, 
                     interaction %in% c("Weak Synchrony", "Strong Synchrony") & Lag %in% c("1", "2") & Process_error == "0"),
       aes(x = time, group = scenario, col = direction)) +
  geom_line(aes(y = LPI_final)) +
  geom_line(aes(y = LPI_final_true), lty = 2) +
  facet_grid(interaction~Lag, labeller = label_both) +
  theme_bw() + format_lpiplots
```


#### Process error = 0.1

```{r, fig.height=5}
ggplot(dplyr::filter(df, 
                     interaction %in% c("Weak Synchrony", "Strong Synchrony") & Lag %in% c("1", "2") & Process_error == "0.1"),
       aes(x = time, group = scenario, col = direction)) +
  geom_line(aes(y = LPI_final)) +
  geom_line(aes(y = LPI_final_true), lty = 2) +
  facet_grid(interaction~Lag, labeller = label_both) +
  theme_bw() + format_lpiplots
```


#### Process error = 0.2

```{r, fig.height=5}
ggplot(dplyr::filter(df, 
                     interaction %in% c("Weak Synchrony", "Strong Synchrony") & Lag %in% c("1", "2") & Process_error == "0.2"),
       aes(x = time, group = scenario, col = direction)) +
  geom_line(aes(y = LPI_final)) +
  geom_line(aes(y = LPI_final_true), lty = 2) +
  facet_grid(interaction~Lag, labeller = label_both) +
  theme_bw() + format_lpiplots
```


### Negative covariance {.tabset .tabset-pills}

#### Process error = 0

```{r, fig.height=5}
ggplot(dplyr::filter(df, 
                     interaction %in% c("Weak Asynchrony", "Strong Asynchrony") & Lag %in% c("1", "2") & Process_error == "0"),
       aes(x = time, group = scenario, col = direction)) +
  geom_line(aes(y = LPI_final)) +
  geom_line(aes(y = LPI_final_true), lty = 2) +
  facet_grid(interaction~Lag, labeller = label_both) +
  theme_bw() + format_lpiplots
```

#### Process error = 0.1

```{r, fig.height=5}
ggplot(dplyr::filter(df, 
                     interaction %in% c("Weak Asynchrony", "Strong Asynchrony") & Lag %in% c("1", "2") & Process_error == "0.1"),
       aes(x = time, group = scenario, col = direction)) +
  geom_line(aes(y = LPI_final)) +
  geom_line(aes(y = LPI_final_true), lty = 2) +
  facet_grid(interaction~Lag, labeller = label_both) +
  theme_bw() + format_lpiplots
```


#### Process error = 0.2

```{r, fig.height=5}
ggplot(dplyr::filter(df, 
                     interaction %in% c("Weak Asynchrony", "Strong Asynchrony") & Lag %in% c("1", "2") & Process_error == "0.2"),
       aes(x = time, group = scenario, col = direction)) +
  geom_line(aes(y = LPI_final)) +
  geom_line(aes(y = LPI_final_true), lty = 2) +
  facet_grid(interaction~Lag, labeller = label_both) +
  theme_bw() + format_lpiplots
```

### Summary {.tabset .tabset-pills}

#### Process error = 0

```{r, fig.height=5}
df_lag <- dplyr::filter(df, interaction != "No Synchrony")
a <- accuracy_plot(dplyr::filter(df_lag, Process_error == "0"), 
                   comparison_variable = "direction", 
                   colour_variable = "Lag") + 
                    facet_wrap(~interaction, nrow = 1) + #labs(x = "Lag") +
  theme(legend.position = "none") + scale_color_manual(values = pal_lags) + 
  scale_fill_manual(values = pal_lags)
b <- precision_plot(dplyr::filter(df_lag, Process_error == "0"), 
                   comparison_variable = "direction", 
                   colour_variable = "Lag") + 
                   facet_wrap(~interaction, nrow = 1) + 
  #labs(x = "Lag") +
  #coord_cartesian(ylim = c(-2,30)) +
  theme(legend.position = "bottom") + scale_color_manual(values = pal_lags) + scale_fill_manual(values = pal_lags)
a / b
# plotly::ggplotly(a)
# plotly::ggplotly(b)
ggsave("~/Documents/GitHub/LPI-sensitivity/figures/fig4_lag.png", width = 8, height = 7)
```

#### Process error = 0.1

```{r, fig.height=5}
df_lag <- dplyr::filter(df, interaction != "No Synchrony")
a <- accuracy_plot(dplyr::filter(df_lag, Process_error == "0.1"), 
                   comparison_variable = "direction", 
                   colour_variable = "Lag") + 
                    facet_wrap(~interaction, nrow = 1) + 
  theme(legend.position = "top") + scale_color_manual(values = pal_lags) + 
  scale_fill_manual(values = pal_lags)
b <- precision_plot(dplyr::filter(df_lag, Process_error == "0.1"), 
                   comparison_variable = "direction", 
                   colour_variable = "Lag") + 
                    facet_wrap(~interaction, nrow= 1) + 
  theme(legend.position = "top") + 
  scale_color_manual(values = pal_lags) + 
  scale_fill_manual(values = pal_lags)
a / b
# plotly::ggplotly(a)
# plotly::ggplotly(b)
```


#### Process error = 0.2

```{r, fig.height=5}
df_lag <- dplyr::filter(df, interaction != "No Synchrony")
a <- accuracy_plot(dplyr::filter(df_lag, Process_error == "0.2"), 
                   comparison_variable = "direction", 
                   colour_variable = "Lag") + 
                    facet_wrap(~interaction, nrow = 1) + 
  theme(legend.position = "top")+ scale_color_manual(values = pal_lags) + scale_fill_manual(values = pal_lags)
b <- precision_plot(dplyr::filter(df_lag, Process_error == "0.2"), 
                   comparison_variable = "direction", 
                   colour_variable = "Lag") + 
                    facet_wrap(~interaction, nrow = 1) + 
  theme(legend.position = "top") + scale_color_manual(values = pal_lags) + scale_fill_manual(values = pal_lags)
a / b
# plotly::ggplotly(a)
# plotly::ggplotly(b)
```

    The LPI is not sensitive to lags of 1 or 2 time steps.
    
```{r, fig.height = 15, include = FALSE}
# process error comparison plot
df_lag %>%
  group_by(direction, interaction, Lag, Process_error) %>%
  summarise(mean_se(accuracy)) %>%
ggplot(aes(col = Process_error, y = y, x = Lag)) +
  geom_errorbar(aes(ymin = ymin, ymax = ymax), lwd = .5, width = 0) +
  geom_point(size = 2.5) +
  geom_hline(yintercept = 0, lty = 2, lwd = .2) +
  facet_grid(interaction~direction)+#, scales = "free") +
  scale_color_manual(values = pal_error) +
  labs(y = "Difference from true LPI", 
         x = "", 
         title = "Accuracy",
         col = "Process error") +
 theme(legend.position = "bottom") 
ggsave("~/Documents/GitHub/LPI-sensitivity/figures/figsupp_lag_accuracy.png", width = 5.71, height = 7.42)
df_lag %>%
  group_by(direction, interaction, Lag, Process_error) %>%
  summarise(mean_se(CI_diff)) %>%
ggplot(aes(col = Process_error, y = y, x = Lag)) +
  geom_errorbar(aes(ymin = ymin, ymax = ymax), lwd = .5, width = 0) +
  geom_point(size = 2.5) +
  geom_hline(yintercept = 0, lty = 2, lwd = .2) +
  facet_grid(interaction~direction)+#, scales = "free") +
  scale_color_manual(values = pal_error) +
  labs(y = "Difference in interval width", 
         x = "", 
         title = "Precision",
         col = "Process error") +
 theme(legend.position = "bottom")
ggsave("~/Documents/GitHub/LPI-sensitivity/figures/figsupp_lag_precision.png", width = 5.71, height = 7.42)

```

## Summary table
    
```{r, include = TRUE}
df_lag %>%
  group_by(direction, interaction, Lag, Process_error) %>%
  summarise(mean_accuracy = round(mean(accuracy),3),
            se_accuracy = round(se(accuracy), 3),
            mean_precision = round(mean(CI_diff),3),
            se_precision = round(se(CI_diff),3)) %>% 
  kableExtra::kable() %>%
  scroll_box(width = "100%", height = "200px")
```


```{r, fig.height = 9, fig.width = 9}
success = df_lag %>% group_by(direction, interaction, Lag, Process_error) %>%
  count(true_within_rlpiCI) %>%
  mutate(perc = n/sum(n)) %>% 
  ungroup() %>%
  filter(true_within_rlpiCI == "Success")
  
  
success %>% 
  ggplot() +
  geom_tile(aes(x = direction, y = interaction, fill = perc)) +
  facet_grid(Lag~Process_error, labeller = label_both) + 
  scale_fill_distiller(palette = "RdYlGn", direction = 1) +
  labs(fill = "Success rate", y = "", x = "")

success %>% kable() %>% kable_styling(bootstrap_options = "striped") %>%
  scroll_box(width = "100%", height = "200px")
```

```{r, fig.width=7, fig.height = 10}
reasonable_precision_plot(df_lag, comparison_variable = "interaction") +
facet_grid(Lag~Process_error)
```

```{r, fig.cap="Ability to capture the true LPI", fig.width=7, fig.height = 5}
overlap_precision_plot(filter(df_lag, Process_error == "0"), comparison_variable = "interaction") +
  facet_wrap(~Lag)
percentile_precision_plot(filter(df_lag, Process_error == "0"), comparison_variable = "interaction") +
  facet_wrap(~Lag)
```


## Do the confidence intervals widen when there is more noise introduced into the time series?

Expectation: in each case, the width of the CI should increase with process error. The width should also increase when there is strong asynchrony or synchrony.

Not really...

```{r, fig.height = 5}
ggplot(df_sc1) +
  geom_boxplot(aes(fill = Process_error, y = rlpiCI_width, x = direction)) + 
  scale_fill_manual(values = pal_error) 
```

```{r, fig.height = 5}
ggplot(df_cov) +
  geom_boxplot(aes(fill = Process_error, y = rlpiCI_width, x = interaction)) + 
  facet_wrap(~direction, nrow = 3) +
  scale_fill_manual(values = pal_error) 
```

```{r, fig.height = 5}
ggplot(df_lag) +
  geom_boxplot(aes(fill = Process_error, y = rlpiCI_width, x = interaction)) + 
  facet_grid(Lag~direction) +
  scale_fill_manual(values = pal_error) 
```
