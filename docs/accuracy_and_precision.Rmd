---
title: "Accuracy and precision of the LPI"
output:
  bookdown::html_document2:
    toc: yes
    toc_depth: 1
    toc_float:
      collapsed: no
      smooth_scroll: no
    number_sections: no
    theme: flatly
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
# libraries
require(kableExtra)
require(ggplot2)
require(patchwork)
require(dplyr)
require(tidyr)
require(tidyselect)

# chunk params
knitr::opts_chunk$set(echo = FALSE, 
                      warning=FALSE, 
                      message=FALSE,
                      fig.height = 3, fig.align = "center")

# set ggplot theme
theme_set(theme_linedraw())
format_lpiplots <- list(
  theme(legend.position = "none"),
  labs(x = "", y = "LPI"),
  scale_x_continuous(breaks = seq(from = 0, to = 10, by = 2)),
  ylim(c(0,1.8)))

# load results
df <- readRDS("~/Documents/GitHub/LPI-sensitivity/outputs/all_results.RDS")

# colour palette for interactions
colours <- c("0.2" = "#e66101", 
             "0.1" = "#fdb863", 
             "-0.1"= "#b2abd2", 
             "-0.2" = "#5e3c99")
```

```{r}
df$Process_error <- factor(df$Process_error, levels = c("0", "0.1", "0.2"))
df$interaction <- factor(df$interaction, 
                         levels = c("-0.2", "-0.1", "0", "0.1", "0.2"))
```

```{r}
accuracy_plot <- function(df_subset, comparison_variable, colour_variable = "direction") {
  ggplot(df_subset,
       aes(x = get(comparison_variable), 
           y = accuracy_boot, 
           group = scenario,
           col = get(colour_variable))) +
  # geom_violin(aes(group = scenario, fill = get(colour_variable)), 
  #             lwd = 0, alpha = .1) +
  stat_summary(fun.data = mean_se, 
               fun.args = list(mult=1),
               geom = "pointrange", 
               position = position_dodge(width = .5)) + 
  labs(x = "", 
       y = "Difference from true LPI (%)", 
       title = "Accuracy", col = colour_variable) +
  theme(legend.position = "bottom") +
    coord_cartesian(ylim = c(-10,120))
}

precision_plot <- function(df_subset, 
                           comparison_variable, 
                           colour_variable = "direction"){
  ggplot(data = df_subset, aes(x = get(comparison_variable), 
                        group = scenario,
                        col = get(colour_variable))) +
  stat_summary(aes(y = interval_diff),
               fun.data = mean_se,
               fun.args = list(mult=1),
               geom = "pointrange",
               position = position_dodge(width = .5)) +
    labs(y = "Difference in interval width", 
         x = "", 
         title = "Precision",
         col = colour_variable) +
 theme(legend.position = "bottom")
}

# precision_plot <- function(df_subset, comparison_variable, colour_variable = "direction"){
#   ggplot(df_subset,
#        aes(x = get(comparison_variable), 
#            y = interval_width, 
#            group = scenario,
#            col = get(colour_variable))) +
#   # geom_violin(aes(group = scenario, fill = get(colour_variable)), 
#   #             lwd = 0, alpha = .1) +
#   stat_summary(fun.data = mean_se, 
#                fun.args = list(mult=1),
#                geom = "pointrange", 
#                position = position_dodge(width = .5)) + 
#   labs(x = "", y = "CI Width / LPI value", title = "Precision", col = colour_variable) +
#   theme(legend.position = "bottom") +
#     coord_cartesian(ylim = c(0,2))
# }
```

***

## Mechanistic simulations of population dynamics

We simulated antagonistic population dynamics using a discrete Lotka-Volterra competition model, where each population's growth rate is influenced by the fluctuations in a competitor population.
Pairs of populations were simulated according to:

```{=tex}
\begin{equation}
N_i(t+1) = N_i(t) + \lambda_i * N_i(t)
\end{equation}
```

where $N_i$ is the size of population $i$, $t$ is each time step, and $\lambda$ is the true growth rate of population $i$.
The true growth rate ($\lambda$) is determined by:

```{=tex}
\begin{equation}
\lambda_i = r*(1-\frac{(N_i(t) + \alpha_{ji}N_j(t))}{K_i})
\end{equation}
```

where $r$ is population $i$'s maximum growth rate, $\alpha_{ji}$ is the interaction effect of population $j$ on population $i$, $N_j$ is the size of population $j$, and $K_i$ is the carrying capacity of population $i$.

To test index sensitivity to error, we introduced process and observation error into the generated population time series.

```{r}
params <- data.frame("Value" = c(10, 10, 100, 1.5), 
                     row.names = c("Number of population pairs", 
                                   "Time steps",
                                   "Initial size (N0)",
                                   "Maximum growth rate (r)"))
kbl(params, booktabs = TRUE, caption = "Constant simulation parameters") %>%
  kable_styling(position = "center", latex_options = "hold_position")
```

***

### Biodiversity change scenarios

#### Direction of change

To test index sensitivity to direction of change, we generated three scenarios of population-level biodiversity change.

We varied carrying capacity through time to drive populations to:

* (1) decline in response to decreasing carrying capacity, representing situations where habitats are lost or altered,   
* (2) remain stable in response to constant carrying capacity, where habitats are left untouched, or 
* (3) increase in response to increasing carrying capacity, where habitat quality and/or availability increases through time.

In each scenario, carrying capacity begins at $K = 100$ and each population's initial size is exactly at this carrying capacity ($N_0 = 100$). 

```{r, fig.cap = "Carrying capacity trends used to generate the biodiversity change scenarios.", fig.align="center"}
## CARRYING CAPACITY SCENARIOS -------------------------------------------------
steps = 10
K_increase = 100 + 4*c(0:9)
K_stable = rep(100, 10)
K_decline = 100 - 4*c(0:9)
# plot these!
K_plot <- data.frame(
  time = 1:steps,
  scenario = factor(c(rep("increase", steps), rep("stable", steps), rep("decline", steps)),
                    levels = c("increase", "stable", "decline")),
  K = c(K_increase, K_stable, K_decline)
)
ggplot(K_plot) +
  geom_line(aes(x = time, y = K, col = scenario)) +
  labs(x = "", y = "Carrying capacity (K)", col = "Biodiversity change\n scenario") +
  theme(legend.position = "right") +
  scale_x_continuous(breaks = c(1:10))
```


#### Covariance

To test whether the LPI is sensitive to lags in the covariance between populations, we then generated two levels of lag in the interaction effect dictating how populations covary through time:

* The first level was lag-1, where the interaction effect of populations $i$ on populations $j$ was dependent on the abundance of populations $i$ at the previous time step ($t-1$).
* The second level was lag-2, where this interaction effect depended instead on the abundance of populations $i$ from two time steps ago ($t-2$).

***

## Measuring index sensitivity

For each biodiversity change scenario, index sensitivity was measured as the accuracy and precision of the calculated Living Planet Index when compared to the true biodiversity change trend. This true LPI trend was obtained by calculating the index values through time based on a population generated from the same parameters we used to generate populations for each scenario, without any added process error.


We measured **accuracy** as the difference between the calculated LPI and true LPI trend at each time step, expressed as a percentage of the true LPI value at each step to allow for comparison between scenarios:

$$accuracy = \frac{LPI_{calculated} - LPI_{true}}{LPI_{true}} * 100% $$ 

As a first metric of **precision**, we evaluated whether the true LPI trend fell within the 95% confidence interval around the calculated LPI trend obtained from bootstrap resampling at each time step. As a second precision metric, we measured precision as the difference between the expected uncertainty interval and the width of the 95% confidence interval expressed as a percentage of the calculated LPI value at each step to allow comparison between scenarios. The expected uncertainty interval is determined based on the process and observation errors introduced into the simulated population trends. I calculated each population's growth rate with and without introduced error, and took the difference between the two to get a measure of the total introduced uncertainty in the growth rates. Then, I converted the difference between these growth rates to the same scale as the LPI:

$$ precision = \frac{LPI_{CIwidth} - LPI_{uncertainty}}{LPI_{calculated}} * 100% $$

***

## Is the LPI sensitive to *direction of change*? {.tabset .tabset-pills}

```{r}
## make table ##
params <- data.frame("i" = c(0, 
                             paste0("+/- ", 5), 
                             paste0("+/- ", " 0, 0.1, 0.2"), 0), 
                     "j" = c(0, 
                             paste0("+/- ", 5), 
                             paste0("+/- ", "0, 0.1, 0.2"), 0),
                     row.names = c("Interaction effect (alpha)",
                                   "Observation error",
                                   "Process error", 
                                   "Lag"))
kbl(params, booktabs = TRUE, caption = "Simulation parameters") %>%
  kable_styling(position = "center", latex_options = "hold_position")
```

### Process error = 0

```{r, fig.cap="True and calculated LPI trends for each direction of biodiversity change."}
# this was scenario 1, so filter for just that one
df_sc1 <- dplyr::filter(df, scenario %in% paste0("scenario1", LETTERS[1:9]))
ggplot(dplyr::filter(df_sc1, Process_error == "0"),
       aes(x = time, col = direction, group = scenario)) +
  geom_ribbon(aes(ymin = cilo_boot, ymax = cihi_boot, 
                   fill = direction), alpha = .3, lwd = 0) +
  geom_line(aes(y = LPI_true), lty = 2, lwd = .2, col = "grey") +
  geom_line(aes(y = LPI_boot)) +
  theme_bw() + format_lpiplots
```

### Process error = 0.1

```{r, fig.cap="True and calculated LPI trends for each direction of biodiversity change."}
ggplot(dplyr::filter(df_sc1, Process_error == "0.1"),
       aes(x = time, col = direction, group = scenario)) +
  geom_ribbon(aes(ymin = cilo_boot, ymax = cihi_boot, 
                   fill = direction), alpha = .3, lwd = 0) +
  geom_line(aes(y = LPI_true), lty = 2, lwd = .2, col = "grey") +
  geom_line(aes(y = LPI_boot)) +
  theme_bw() + format_lpiplots
```


### Process error = 0.2

```{r, fig.cap="True and calculated LPI trends for each direction of biodiversity change."}
ggplot(dplyr::filter(df_sc1, Process_error == "0.2"),
       aes(x = time, col = direction, group = scenario)) +
  geom_ribbon(aes(ymin = cilo_boot, ymax = cihi_boot, 
                   fill = direction), alpha = .3, lwd = 0) +
  geom_line(aes(y = LPI_true), lty = 2, lwd = .2, col = "grey") +
  geom_line(aes(y = LPI_boot)) +
  theme_bw() + format_lpiplots
```

## Summary {.tabset .tabset-pills}

### Process error = 0

```{r, fig.cap = "LPI sensitivity to direction of change."}
a <- accuracy_plot(filter(df_sc1, Process_error == "0"), "direction") + 
  theme(legend.position = "none")
b <- precision_plot(filter(df_sc1, Process_error == "0"), "direction") + 
  theme(legend.position = "none")
a + b
```

### Process error = 0.1

```{r, fig.cap = "LPI sensitivity to direction of change."}
a <- accuracy_plot(filter(df_sc1, Process_error == "0.1"), "direction") + 
  theme(legend.position = "none")
b <- precision_plot(filter(df_sc1, Process_error == "0.1"), "direction") + 
  theme(legend.position = "none")
a + b
```

### Process error = 0.2

```{r, fig.cap = "LPI sensitivity to direction of change."}
a <- accuracy_plot(filter(df_sc1, Process_error == "0.2"), "direction") + 
  theme(legend.position = "none")
b <- precision_plot(filter(df_sc1, Process_error == "0.2"), "direction") + 
  theme(legend.position = "none")
a + b
```

```{r, out.width = 9, include=FALSE}
# NOTE: this is all levels of process error together, so must update if needed to show this

# calculate mean accuracy and mean precision with standard error
se <- function(x) sqrt(var(x)/length(x))
df_sc1 %>% filter(Process_error == "0") %>%
  group_by(direction) %>%
  summarise(mean_accuracy = round(mean(accuracy_boot),2),
            #se_accuracy = round(se(accuracy_boot),2),
            mean_precision = round(mean(interval_width),2)) %>% #,
            #se_precision = round(se(interval_width),2)) %>%
  kableExtra::kable() %>% kableExtra::kable_styling()
```

## {-}

    The LPI is sensitive to direction of change:
    * declining trends are overestimated by the LPI 
    * declining trends are estimated with lower precision


***

## Is the LPI sensitive to *covariance*? {.tabset .tabset-pills}

To test whether the LPI is sensitive to covariance between populations, we generated biodiversity change scenarios with two types of interaction effects ($\alpha$) between populations:

* For the first scenario, we set a **negative interaction effect** to represent an antagonistic interaction between populations $i$ and $j$, such as a competitive or predator-prey relationship, which causes negative covariance.  
* The second scenario was based on a **positive interaction effect** of the same magnitude(s) to replicate a positive interaction between populations $i$ and $j$, and therefore positive covariance.

Each type of interaction was tested at two interaction strengths. All interaction effects were immediate, meaning there was no time lag in the covariance in the populations' growth rates. 

```{r}
## make table ##
params <- data.frame("i" = c(0, 
                             paste0("+/- ", 5), 
                             paste0("+/- ", " 0, 0.1, 0.2"), 0), 
                     "j" = c(0, 
                             paste0("+/- ", 5), 
                             paste0("+/- ", "0, 0.1, 0.2"), 0),
                     row.names = c("Interaction effect (alpha)",
                                   "Observation error",
                                   "Process error",
                                   "Lag"))
kbl(params, booktabs = TRUE, caption = "Simulation parameters") %>%
  kable_styling(position = "center", latex_options = "hold_position")

# combine into one df for later
df_sc2 <- df[grepl("^scenario2", df$scenario), ]
df_sc3 <- df[grepl("^scenario3", df$scenario), ]
df_cov <- rbind(df_sc2, df_sc3)
```

### Process error = 0

```{r, fig.cap="True and calculated LPI trends for each scenario.", fig.height = 7}
df_sc2 <- df[grepl("^scenario2", df$scenario), ] %>% dplyr::filter(Process_error == "0")
df_sc3 <- df[grepl("^scenario3", df$scenario), ] %>% dplyr::filter(Process_error == "0")
a <- ggplot(df_sc2,
       aes(x = time, group = scenario, col = direction)) +
  geom_line(aes(y = LPI_boot)) +
  geom_line(aes(y = LPI_true), lty = 2) +
  facet_wrap(~interaction) +
  theme_bw() + format_lpiplots +
  labs(title = "Predation (negative covariation)")
b <- ggplot(df_sc3,
       aes(x = time, group = scenario, col = direction)) +
  geom_line(aes(y = LPI_boot)) +
  geom_line(aes(y = LPI_true), lty = 2) +
  facet_wrap(~interaction) +
  theme_bw() + format_lpiplots +
  labs(title = "Competition (positive covariation)")
a / b
```


### Process error = 0.1

```{r, fig.cap="True and calculated LPI trends for each scenario.", fig.height = 7}
df_sc2 <- df[grepl("^scenario2", df$scenario), ] %>% dplyr::filter(Process_error == "0.1")
df_sc3 <- df[grepl("^scenario3", df$scenario), ] %>% dplyr::filter(Process_error == "0.1")
a <- ggplot(df_sc2,
       aes(x = time, group = scenario, col = direction)) +
  geom_line(aes(y = LPI_boot)) +
  geom_line(aes(y = LPI_true), lty = 2) +
  facet_wrap(~interaction) +
  theme_bw() + format_lpiplots +
  labs(title = "Predation (negative covariation)")
b <- ggplot(df_sc3,
       aes(x = time, group = scenario, col = direction)) +
  geom_line(aes(y = LPI_boot)) +
  geom_line(aes(y = LPI_true), lty = 2) +
  facet_wrap(~interaction) +
  theme_bw() + format_lpiplots +
  labs(title = "Competition (positive covariation)")
a / b
```

### Process error = 0.2

```{r, fig.cap="True and calculated LPI trends for each scenario.", fig.height = 7}
df_sc2 <- df[grepl("^scenario2", df$scenario), ] %>% dplyr::filter(Process_error == "0.2")
df_sc3 <- df[grepl("^scenario3", df$scenario), ] %>% dplyr::filter(Process_error == "0.2")
a <- ggplot(df_sc2,
       aes(x = time, group = scenario, col = direction)) +
  geom_line(aes(y = LPI_boot)) +
  geom_line(aes(y = LPI_true), lty = 2) +
  facet_wrap(~interaction) +
  theme_bw() + format_lpiplots +
  labs(title = "Predation (negative covariation)")
b <- ggplot(df_sc3,
       aes(x = time, group = scenario, col = direction)) +
  geom_line(aes(y = LPI_boot)) +
  geom_line(aes(y = LPI_true), lty = 2) +
  facet_wrap(~interaction) +
  theme_bw() + format_lpiplots +
  labs(title = "Competition (positive covariation)")
a / b
```


## Summary {.tabset .tabset-pills}

### Process error = 0

```{r, fig.cap = "LPI sensitivity to direction of change and covariance.", fig.height = 4}
df_temp <- dplyr::filter(df_cov, Process_error == "0") 
a <- accuracy_plot(df_temp, comparison_variable = "direction", colour_variable = "interaction") +
  scale_color_manual(values = colours)
b <- precision_plot(df_temp, comparison_variable = "direction", colour_variable = "interaction") +
  #coord_cartesian(ylim = c(0,10)) +
  scale_color_manual(values = colours) #+  scale_fill_manual(values = colours) 
a + b
```

### Process error = 0.1

```{r, fig.cap = "LPI sensitivity to direction of change and covariance.", fig.height = 4}
df_temp <- dplyr::filter(df_cov, Process_error == "0.1") 
a <- accuracy_plot(df_temp, comparison_variable = "direction", colour_variable = "interaction") +
  scale_color_manual(values = colours)
b <- precision_plot(df_temp, comparison_variable = "direction", colour_variable = "interaction") +
  coord_cartesian(ylim = c(0,10)) +
  scale_color_manual(values = colours) +
    scale_fill_manual(values = colours)
a + b
```

### Process error = 0.2

```{r, fig.cap = "LPI sensitivity to direction of change and covariance.", fig.height = 4}
df_temp <- dplyr::filter(df_cov, Process_error == "0.2") 
a <- accuracy_plot(df_temp, comparison_variable = "direction", colour_variable = "interaction") +
  scale_color_manual(values = colours)
b <- precision_plot(df_temp, comparison_variable = "direction", colour_variable = "interaction") +
  #coord_cartesian(ylim = c(0,10)) +
  scale_color_manual(values = colours) 
a + b
```


```{r, include = FALSE}
df_cov %>% #filter(Process_error == "0") %>%
  group_by(direction, interaction) %>%
  summarise(mean_accuracy = round(mean(accuracy_boot),2),
            se_accuracy = round(se(accuracy_boot), 2),
            mean_precision = round(mean(interval_width),2),
            se_precision = round(se(interval_width), 2)) %>% 
  kableExtra::kable()
```

    The LPI is sensitive to covariance when trends are declining:  
    
    * The LPI is particularly sensitive to negative covariance in declining trends, which are very overestimated (alpha = 0.1 and 0.2)  
    * growing and stable trends are slightly overestimated when there is high positive covariance  
    * however, this sensitivity does not change at different levels of process error   
    
## Is the LPI sensitive to *lagged* covariance? 

We introduced two levels of lag in the interaction effect that influences how populations covary through time:

* The first level was **lag-1**, where the interaction effect of populations $i$ on populations $j$ was dependent on the abundance of populations $i$ at the previous time step ($t-1$).
* The second level was **lag-2**, where this interaction effect depended instead on the abundance of populations $i$ from two time steps ago ($t-2$).

Both of these lags were introduced into positively and negatively covarying populations shown above.

```{r}
## make table ##
params <- data.frame("i" = c(0, 
                             paste0("+/- ", 5), 
                             paste0("+/- ", " 0, 0.1, 0.2"),
                             c("0, 1, 2")), 
                     "j" = c(0, 
                             paste0("+/- ", 5), 
                             paste0("+/- ", "0, 0.1, 0.2"),
                             c("0, 1, 2")),
                     row.names = c("Interaction effect (alpha)",
                                   "Observation error",
                                   "Process error",
                                   "Lag"))
kbl(params, booktabs = TRUE, caption = "Simulation parameters") %>%
  kable_styling(position = "center", latex_options = "hold_position")

# combine into one df for later
df_sc2 <- df[grepl("^scenario2", df$scenario), ]
df_sc3 <- df[grepl("^scenario3", df$scenario), ]
df_cov <- rbind(df_sc2, df_sc3)
```

### Positive covariance {.tabset .tabset-pills}

#### Process error = 0

```{r, fig.height=5}
ggplot(dplyr::filter(df, 
                     interaction %in% c("-0.1", "-0.2") & Lag %in% c("1", "2") & Process_error == "0"),
       aes(x = time, group = scenario, col = direction)) +
  geom_line(aes(y = LPI_boot)) +
  geom_line(aes(y = LPI_true), lty = 2) +
  facet_grid(interaction~Lag, labeller = label_both) +
  theme_bw() + format_lpiplots
```


#### Process error = 0.1

```{r, fig.height=5}
ggplot(dplyr::filter(df, 
                     interaction %in% c("-0.1", "-0.2") & Lag %in% c("1", "2") & Process_error == "0.1"),
       aes(x = time, group = scenario, col = direction)) +
  geom_line(aes(y = LPI_boot)) +
  geom_line(aes(y = LPI_true), lty = 2) +
  facet_grid(interaction~Lag, labeller = label_both) +
  theme_bw() + format_lpiplots
```


#### Process error = 0.2

```{r, fig.height=5}
ggplot(dplyr::filter(df, 
                     interaction %in% c("-0.1", "-0.2") & Lag %in% c("1", "2") & Process_error == "0.2"),
       aes(x = time, group = scenario, col = direction)) +
  geom_line(aes(y = LPI_boot)) +
  geom_line(aes(y = LPI_true), lty = 2) +
  facet_grid(interaction~Lag, labeller = label_both) +
  theme_bw() + format_lpiplots
```


### Negative covariance {.tabset .tabset-pills}

#### Process error = 0

```{r, fig.height=5}
ggplot(dplyr::filter(df, 
                     interaction %in% c("0.1", "0.2") & Lag %in% c("1", "2") & Process_error == "0"),
       aes(x = time, group = scenario, col = direction)) +
  geom_line(aes(y = LPI_boot)) +
  geom_line(aes(y = LPI_true), lty = 2) +
  facet_grid(interaction~Lag, labeller = label_both) +
  theme_bw() + format_lpiplots
```

#### Process error = 0.1

```{r, fig.height=5}
ggplot(dplyr::filter(df, 
                     interaction %in% c("0.1", "0.2") & Lag %in% c("1", "2") & Process_error == "0.1"),
       aes(x = time, group = scenario, col = direction)) +
  geom_line(aes(y = LPI_boot)) +
  geom_line(aes(y = LPI_true), lty = 2) +
  facet_grid(interaction~Lag, labeller = label_both) +
  theme_bw() + format_lpiplots
```


#### Process error = 0.2

```{r, fig.height=5}
ggplot(dplyr::filter(df, 
                     interaction %in% c("0.1", "0.2") & Lag %in% c("1", "2") & Process_error == "0.2"),
       aes(x = time, group = scenario, col = direction)) +
  geom_line(aes(y = LPI_boot)) +
  geom_line(aes(y = LPI_true), lty = 2) +
  facet_grid(interaction~Lag, labeller = label_both) +
  theme_bw() + format_lpiplots
```

### Summary {.tabset .tabset-pills}

#### Process error = 0

```{r, fig.height=8}
df_lag <- dplyr::filter(df, interaction != "0")
a <- accuracy_plot(dplyr::filter(df_lag, Process_error == "0"), 
                   comparison_variable = "Lag", colour_variable = "interaction") + 
                    facet_wrap(~direction) + labs(x = "Lag") +
  scale_color_manual(values = colours) +
  theme(legend.position = "top")
b <- precision_plot(dplyr::filter(df_lag, Process_error == "0"), 
                   comparison_variable = "Lag", 
                   colour_variable = "interaction") + 
                   facet_wrap(~direction) + 
  labs(x = "Lag") +
  scale_color_manual(values = colours) +
  scale_fill_manual(values = colours) +
  theme(legend.position = "top") #+ coord_cartesian(ylim = c(0, 10))
a / b
```

#### Process error = 0.1

```{r, fig.height=8}
df_lag <- dplyr::filter(df, interaction != "0")
a <- accuracy_plot(dplyr::filter(df_lag, Process_error == "0.1"), 
                   comparison_variable = "Lag", colour_variable = "interaction") + 
                    facet_wrap(~direction) + labs(x = "Lag") +
  scale_color_manual(values = colours) +
  theme(legend.position = "top")
b <- precision_plot(dplyr::filter(df_lag, Process_error == "0.1"), 
                   comparison_variable = "Lag", colour_variable = "interaction") + 
                    facet_wrap(~direction) + 
  labs(x = "Lag") +
  scale_color_manual(values = colours) +
  scale_fill_manual(values = colours) +
  theme(legend.position = "top") #+ coord_cartesian(ylim = c(0,10))
a / b
```


#### Process error = 0.2

```{r, fig.height=8}
df_lag <- dplyr::filter(df, interaction != "0")
a <- accuracy_plot(dplyr::filter(df_lag, Process_error == "0.2"), 
                   comparison_variable = "Lag", colour_variable = "interaction") + 
                    facet_wrap(~direction) + labs(x = "Lag") +
  scale_color_manual(values = colours) +
  theme(legend.position = "top")
b <- precision_plot(dplyr::filter(df_lag, Process_error == "0.2"), 
                   comparison_variable = "Lag", colour_variable = "interaction") + 
                    facet_wrap(~direction) + 
  scale_color_manual(values = colours) + 
    scale_fill_manual(values = colours) +
  labs(x = "Lag") +
  theme(legend.position = "top") #+
  #coord_cartesian(ylim = c(0,10))
a / b
```

    The LPI is not sensitive to lags of 1 or 2 time steps.